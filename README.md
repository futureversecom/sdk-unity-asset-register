# Asset Register SDK

A Unity client for the Asset Register. Provides an API for creating and sending requests to the AR GraphQL server.

> [!TIP]
> See https://ar-docs.futureverse.app/ for details on the Asset Register.

## Installation

Go to the Unity Package Manager window, and select `Add package from git URL...` and enter this link https://github.com/futureversecom/sdk-unity-asset-register.git?path=Assets/Plugins/AssetRegister (append `#vX.X.X` to specify a version). Alternatively, you can get a .unitypackage from the Releases page.

## Getting Started

This example script shows a simple Asset Register request. It queries the Asset schema, including only the `id` field. After checking that the request has succeeded, the response is parsed for the Asset, and the `id` is logged.

```csharp
public class Example : MonoBehaviour
{
  [SerializeField] private MonoClient _client;
  [SerializeField] private string _collectionId;
  [SerializeField] private string _tokenId;

  private IEnumerator Start()
  {
    IResponse response = null;

    yield return AR.NewQuery()
      .Add(new AssetQuery(_collectionId, _tokenId))
        .WithField(a => a.Id)
      .Execute(_client, r => response = r);

    if (!response.Success)
    {
      Debug.LogError(response.Error);
      yield break;
    }

    if (response.TryGetModel<Asset>(out var asset))
    {
      Debug.Log(asset.Id);
    }
  }
}
```

To use this script, add it to a GameObject in your scene. You will also need to add the MonoClient component, and add it to the `Client` field of the `Example` component. 

![image](https://github.com/user-attachments/assets/8f39e359-59f0-4d83-8cc5-00ef9e4db993)

To complete the test, you can use

* Collection ID: `11155111:evm:0x85225575aae6e8275e3d2be9e86268f916f3e2be`
* Token ID: `400`

Enter play mode, and you should see the Asset's ID pop up in the Console window.

> [!TIP]
> You can see the [equivalent request](https://ar-api.futureverse.cloud/graphql?explorerURLState=N4IgJg9gxgrgtgUwHYBcQC4QEcYIE4CeABAIIDOZCKAFACQoQDWyAkmOkQMop4CWSAcwCEAGiK0oEADZSEUFLwhI2HAMLTZ8xcrBCAlEWAAdJESIBDClWoNmOjvSaswYyTLkKlK8W82edBsamZkS8YCZmAL4mkSAiIABu5nzmAEayZBggwGZGeBFERiC2zkUcRUUieQVFvh7abGWFIBX5SLGRQA) in the Futureverse GraphQL Sandbox.

## Breaking It Down

Let's go through the above script step by step, to see exactly how this is working.

### MonoBehaviour
```csharp
public class Example : MonoBehaviour
{
  [SerializeField] private MonoClient _client;
  [SerializeField] private string _collectionId;
  [SerializeField] private string _tokenId;
```
This script is a MonoBehaviour, so you can add it as a component in your scene. It serializes the Collection ID and Token ID, so you can edit those fields directly on the commponent. It also serializes a MonoClient, which implements the IClient interface. The client is responsible for sending a request and producing a response.

### Building the Query
```csharp
  yield return AR.NewQuery()
    .Add(new AssetQuery(_collectionId, _tokenId))
      .WithField(a => a.Id)
    .Execute(_client, r => response = r);
```
These lines use the RequestBuilder API to create a query of the Asset schema, and then passes that to the client to produce a response.
* `yield return AR.NewQuery()` Creates a new QueryBuilder object.
* `.Add(new AssetQuery(_collectionId, _tokenId))` Adds the Asset query to the QueryBuilder. It requires the Collection ID and Token ID, as these inputs are necessary to run the query.
* `.WithField(a => a.Id)` Uses an Expression to select the ID field of the Asset, and adds that to the query.
* `.Execute(_client, r => response = r);` Is a shorthand for calling `Build()` on the QueryBuilder to produce a request and then `IClient.SendRequest()`. It takes a callback parameter that is used to set the local `response` variable.

### Checking Success
```csharp
  if (!response.Success)
  {
    Debug.LogError(response.Error);
    yield break;
  }
```
Here we check the Success property of the IResponse object that was generated by the QueryBuilder. If that returns false, we know there were errors with the query. We can then print the Error property of the response to see what went wrong, and break from the function.

### Getting the Asset
```csharp
  if (response.TryGetModel<Asset>(out var asset))
  {
    Debug.Log(asset.Id);
  }
```
The IResponse object also provides the `TryGetModel<T>` method. Because multiple queries can be added to the QueryBuilder, the response could contain more than one schema, so the `TryGetModel<T>` usage here checks if the response contains an Asset schema, deserializes it into the out parameter, and then uses that to print the ID. 

> [!IMPORTANT]
> Because we only added the ID field to the query, all other properties of the `asset` object will be null. Use extra `.WithField()` calls to add more fields

## Request Builder

The Request Builder API allows you to create highly customizable queries and mutations, mirroring the functionality of the [Sandbox](https://ar-api.futureverse.cloud/graphql) from within your Unity project to get the exact information you need.

Under the hood, the Request Builder system builds a query tree structure, with the `IMutationBuilder` or `IQueryBuilder` as the root of the tree. The `Add` methods return an `IMemberSubBuilder`. As we will see below, sub-builders, including `IMemberSubBuilder`, can create other sub-builders, adding new nodes to the tree. Any `IMemberSubBuilder` can call `Done` to return the parent builder, letting you navigate the tree.

`IMemberSubBuilder` takes a generic parameter `TType` that determines the type of member that is being built. In the script above, Adding an `AssetQuery` produces an `IMemberSubBuilder` where `TType` is `Asset`. 

To get started building a Request, use the `AR.NewQuery()` or `AR.NewMutation()` methods. These methods produce `IQueryBuilder` and `IMutationBuilder` objects respectively.

### Queries and Mutations

Both the `IQueryBuilder` and `IMutationBuilder` provide an `Add` method, which takes either an `IQuery` or `IMutation` object as a parameter. This allows you to add multiple queries or mutations to the request. The `AssetQuery` object used in the script above is an example of an `IQuery` implementation.

> [!NOTE]
> You cannot add a mutation to a QueryBuilder and vice versa, as GraphQL only supports sending one type of request at a time.

### Fields

Any `IMemberSubBuilder` can call `.WithField()`. This takes a Function Expression as a parameter, where the parameter of the function is of TType. This allows you to write the expression shown in the script above `a => a.Id`. In this case, `a` is of type `Asset`, which lets you access the Id member. Since the member Id is the what is returned by the function expression, the Request Builder knows to add that field to the GraphQL query.

You can also chain members together in the Expression, e.g. `a => a.Collection.ChainID`. This will add both the Collection, and ChainID of the Collection to the query.

### Methods

An `IMemberSubBuilder` can also call `.WithMethod()`. Some GraphQL queries can call sub-methods within the hierarchy of the query. An example of this is `SFTAssetOwnership`, which has a method called `balanceOf`. `balanceOf` takes a string input is a parameter. Using `WithMethod`, you can call `balanceOf` at the end of the method chain, e.g. in a `IMemberSubBuilder` where `TType` is `SFTAssetOwnership`, you can call `.WithMethod(sft => sft.balanceOf("some address"))`.

`.WithMethod()` returns an `IMethodSubBuilder`, where `TType` is the return type of the method call. In the case of `balanceOf`, it is a `SFTBalance` object. This lets you continue adding fields to the query that result from the method call.

> [!CAUTION]
> A runtime exception is thrown if you try to call a method in a `.WithField()` expression. Always use `.WithMethod()` when dealing with method calls.

### Unions

### Interfaces

Interfaces will be supported in a future version.

### Caching Requests

## Helper Methods
