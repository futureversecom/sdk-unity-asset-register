// Copyright (c) 2025, Futureverse Corporation Limited. All rights reserved.

using System;
using System.Collections.Generic;
using System.Linq.Expressions;
using AssetRegister.Runtime.Schema.Input;
using AssetRegister.Runtime.Schema.Objects;
using Plugins.AssetRegister.Runtime.Schema.Interfaces;
#if USING_UNITASK && !AR_SDK_NO_UNITASK
using Cysharp.Threading.Tasks;
using System.Threading;
#else
using System.Collections;
#endif

namespace AssetRegister.Runtime.Interfaces
{
	/// <summary>
	/// Base class for all builders
	/// </summary>
	public interface IBuilder
	{
		/// <summary>
		/// Generates a request object based on the current state of the builder
		/// </summary>
		/// <returns>Request object</returns>
		IRequest Build();
#if USING_UNITASK && !AR_SDK_NO_UNITASK
		/// <summary>
		/// Shortcut method that generates the Request, passes it to the client, and returns the response
		/// </summary>
		/// <param name="client">Asset Register client that processes the request</param>
		/// <param name="cancellationToken">Provides a way to cancel the current process</param>
		/// <returns>Response object generated by the client</returns>
		UniTask<IResponse> Execute(IClient client, CancellationToken cancellationToken = default);
#else
		/// <summary>
		/// Shortcut method that generates the Request, passes it to the client, and returns the response
		/// </summary>
		/// <param name="client">Asset Register client that processes the request</param>
		/// <param name="callback">Callback containing the response object></param>
		/// <returns>IEnumerator to yield on</returns>
		IEnumerator Execute(IClient client, Action<IResponse> callback);
#endif
	}

	/// <summary>
	/// Base class for sub-builders that are created by other builders
	/// </summary>
	/// <typeparam name="TBuilder">Parent builder that created this sub-builder</typeparam>
	public interface ISubBuilder<out TBuilder> : IBuilder where TBuilder : IBuilder
	{
		/// <summary>
		/// Use this when you have added all necessary fields for this builder to get back to the parent.
		/// </summary>
		/// <returns>The parent builder of this builder</returns>
		TBuilder Done();
	}

	/// <summary>
	/// Base class for top level builders that creates queries or mutations
	/// </summary>
	/// <typeparam name="TBuilder">The concrete type that implements this interface</typeparam>
	public interface IRequestBuilder<out TBuilder> : IBuilder where TBuilder : IRequestBuilder<TBuilder>
	{
		/// <summary>
		/// Add a header to the resulting GraphQL request (Content-Type is set by default)
		/// </summary>
		/// <param name="headerName"></param>
		/// <param name="value"></param>
		/// <returns>This builder</returns>
		TBuilder SetHeader(string headerName, string value);

		/// <summary>
		/// Shortcut for setting the Authorization header
		/// </summary>
		/// <param name="authToken">value of the Authorization header</param>
		/// <returns>This builder</returns>
		TBuilder SetAuth(string authToken);
	}

	/// <summary>
	/// Main sub-builder interface for building out requests
	/// </summary>
	/// <typeparam name="TBuilder">Parent builder that created this sub-builder</typeparam>
	/// <typeparam name="TType">Type of the member that this builder can add other members to</typeparam>
	public interface IMemberSubBuilder<out TBuilder, TType> : ISubBuilder<TBuilder>
		where TBuilder : IBuilder
	{
		/// <summary>
		/// Add a field from this member type to the query
		/// </summary>
		/// <param name="fieldSelector">Expression that returns a field from the member type.
		/// e.g. if TType is Asset, fieldSelector can be (Asset a) => a.TokenId, or simply a => a.TokenId
		/// </param>
		/// <typeparam name="TField">Type of the member that is selected by the fieldSelector expression</typeparam>
		/// <returns>This builder</returns>
		IMemberSubBuilder<TBuilder, TType> WithField<TField>(Expression<Func<TType, TField>> fieldSelector);
		/// <summary>
		/// 
		/// </summary>
		/// <param name="input"></param>
		/// <typeparam name="TInput"></typeparam>
		/// <returns></returns>
		IMemberSubBuilder<TBuilder, TType> WithInput<TInput>(TInput input) where TInput : class, IInput;
		/// <summary>
		/// Add a field from this member type to the query. Generates a sub builder where TType is TField
		/// </summary>
		/// <param name="memberSelector">Expression that returns a field from the member type.
		/// e.g. if TType is Asset, fieldSelector can be (Asset a) => a.TokenId, or simply a => a.TokenId
		/// </param>
		/// <typeparam name="TField">Type of the member that is selected by the fieldSelector expression</typeparam>
		/// <returns>The generated sub-builder</returns>
		IMemberSubBuilder<IMemberSubBuilder<TBuilder, TType>, TField> OnMember<TField>(Expression<Func<TType, TField>> memberSelector);
		/// <summary>
		/// Add an array type member from this member to the query
		/// </summary>
		/// <param name="arraySelector">Expression that returns an array type</param>
		/// <typeparam name="TField">The non-array type that the generated sub-builder should track</typeparam>
		/// <typeparam name="TArray">The return type of the expression. Must be an array of TField</typeparam>
		/// <returns>The generated sub-builder</returns>
		IMemberSubBuilder<IMemberSubBuilder<TBuilder, TType>, TField> OnArray<TField, TArray>(
			Expression<Func<TType, TArray>> arraySelector) where TArray : IEnumerable<TField>;
		/// <summary>
		/// Adds a union from this member type to the query
		/// </summary>
		/// <param name="unionSelector">Expression that returns a member of Union type from the member</param>
		/// <typeparam name="TField">The union type that is selected by the fieldSelector expression. Must derive IUnion</typeparam>
		/// <returns>The generated sub-builder</returns>
		IUnionSubBuilder<IMemberSubBuilder<TBuilder, TType>, TField> OnUnion<TField>(
			Expression<Func<TType, TField>> unionSelector) where TField : class, IUnion;
		/// <summary>
		/// 
		/// </summary>
		/// <param name="interfaceSelector"></param>
		/// <typeparam name="TField"></typeparam>
		/// <returns></returns>
		IInterfaceSubBuilder<IMemberSubBuilder<TBuilder, TType>, TField> OnInterface<TField>(
			Expression<Func<TType, TField>> interfaceSelector) where TField : IInterface;
	}

	/// <summary>
	/// Sub-builder for building out union types
	/// </summary>
	/// <typeparam name="TBuilder">Parent builder that created this sub-builder</typeparam>
	/// <typeparam name="TUnion">The union type that this builder is created for</typeparam>
	public interface IUnionSubBuilder<out TBuilder, TUnion> : ISubBuilder<TBuilder>
		where TBuilder : IBuilder where TUnion : class, IUnion
	{
		/// <summary>
		/// Generates a sub-builder for a subtype of this Union
		/// </summary>
		/// <typeparam name="TUnionType">Must derive from TUnion</typeparam>
		/// <returns>Generated sub-builder</returns>
		public IMemberSubBuilder<IUnionSubBuilder<TBuilder, TUnion>, TUnionType> On<TUnionType>()
			where TUnionType : class, TUnion;
		/// <summary>
		/// 
		/// </summary>
		/// <param name="input"></param>
		/// <typeparam name="TInput"></typeparam>
		/// <returns></returns>
		IUnionSubBuilder<TBuilder, TUnion> WithInput<TInput>(TInput input) where TInput : class, IInput;
	}

	public interface IInterfaceSubBuilder<out TBuilder, TInterface> : ISubBuilder<TBuilder>
		where TBuilder : IBuilder
		where TInterface : IInterface
	{
		/// <summary>
		/// Add a field from this member type to the query
		/// </summary>
		/// <param name="fieldSelector">Expression that returns a field from the member type.
		/// e.g. if TType is Asset, fieldSelector can be (Asset a) => a.TokenId, or simply a => a.TokenId
		/// </param>
		/// <typeparam name="TField">Type of the member that is selected by the fieldSelector expression</typeparam>
		/// <returns>This builder</returns>
		IInterfaceSubBuilder<TBuilder, TInterface> WithField<TField>(Expression<Func<TInterface, TField>> fieldSelector);
		/// <summary>
		/// Add a field from this member type to the query. Generates a sub builder where TType is TField
		/// </summary>
		/// <param name="memberSelector">Expression that returns a field from the member type.
		/// e.g. if TType is Asset, fieldSelector can be (Asset a) => a.TokenId, or simply a => a.TokenId
		/// </param>
		/// <typeparam name="TField">Type of the member that is selected by the fieldSelector expression</typeparam>
		/// <returns>The generated sub-builder</returns>
		IMemberSubBuilder<IInterfaceSubBuilder<TBuilder, TInterface>, TField> OnMember<TField>(Expression<Func<TInterface, TField>> memberSelector);
		/// <summary>
		/// 
		/// </summary>
		/// <param name="input"></param>
		/// <typeparam name="TInput"></typeparam>
		/// <returns></returns>
		IInterfaceSubBuilder<TBuilder, TInterface> WithInput<TInput>(TInput input) where TInput : class, IInput;
		/// <summary>
		/// Add an array type member from this member to the query
		/// </summary>
		/// <param name="arraySelector">Expression that returns an array type</param>
		/// <typeparam name="TField">The non-array type that the generated sub-builder should track</typeparam>
		/// <typeparam name="TArray">The return type of the expression. Must be an array of TField</typeparam>
		/// <returns>The generated sub-builder</returns>
		IMemberSubBuilder<IInterfaceSubBuilder<TBuilder, TInterface>, TField> OnArray<TField, TArray>(
			Expression<Func<TInterface, TArray>> arraySelector) where TArray : IEnumerable<TField>;
		/// <summary>
		/// Adds a union from this member type to the query
		/// </summary>
		/// <param name="unionSelector">Expression that returns a member of Union type from the member</param>
		/// <typeparam name="TField">The union type that is selected by the fieldSelector expression. Must derive IUnion</typeparam>
		/// <returns>The generated sub-builder</returns>
		IUnionSubBuilder<IInterfaceSubBuilder<TBuilder, TInterface>, TField> OnUnion<TField>(
			Expression<Func<TInterface, TField>> unionSelector) where TField : class, IUnion;
		/// <summary>
		/// 
		/// </summary>
		/// <param name="interfaceSelector"></param>
		/// <typeparam name="TField"></typeparam>
		/// <returns></returns>
		IInterfaceSubBuilder<IInterfaceSubBuilder<TBuilder, TInterface>, TField> OnInterface<TField>(
			Expression<Func<TInterface, TField>> interfaceSelector) where TField : IInterface;
		/// <summary>
		/// 
		/// </summary>
		/// <typeparam name="TInterfaceType"></typeparam>
		/// <returns></returns>
		public IMemberSubBuilder<IInterfaceSubBuilder<TBuilder, TInterface>, TInterfaceType> On<TInterfaceType>()
			where TInterfaceType : TInterface;
	}
	
	/// <summary>
	/// Top level builder interface for generating queries
	/// </summary>
	public interface IQueryBuilder : IRequestBuilder<IQueryBuilder>
	{
		IMemberSubBuilder<IQueryBuilder, Account> AddAccountsQuery(string[] addresses);
		IMemberSubBuilder<IQueryBuilder, AssetImagesConnection> AddAssetImagesQuery(
			string collectionId,
			string before = default,
			string after = default,
			float first = default,
			float last = default);
		IMemberSubBuilder<IQueryBuilder, Asset> AddAssetQuery(string collectionId, string tokenId);
		IMemberSubBuilder<IQueryBuilder, Namespace> AddNamespaceQuery(string @namespace);
	    IMemberSubBuilder<IQueryBuilder, Asset> AddAssetsByIdsQuery(AssetInput[] assetIds);
	    IMemberSubBuilder<IQueryBuilder, AssetConnection> AddAssetsQuery(
	        bool removeDuplicates = default,
	        Sort[] sort = default,
	        AssetFilter filter = default,
	        string schemaId = default,
	        string[] collectionIds = default,
	        string[] addresses = default,
	        string before = default,
	        string after = default,
	        float first = default,
	        float last = default,
	        string chainId = default,
	        string chainType = default);
	    IMemberSubBuilder<IQueryBuilder, Collection> AddCollectionsBySchemaQuery(string schemaId);
	    IMemberSubBuilder<IQueryBuilder, CollectionConnection> AddCollectionsQuery(
	        string[] addresses,
	        string before = default,
	        string after = default,
	        float first = default,
	        float last = default);
	    IMemberSubBuilder<IQueryBuilder, DomainsConnection> AddDomainsQuery(
	        string before = default,
	        string after = default,
	        float first = default,
	        float last = default);
	    IMemberSubBuilder<IQueryBuilder, GenericTokenBalance> AddGenericTokenBalancesQuery(
	        GenericTokenFilter filter = default,
	        string[] addresses = null,
	        string[] genericTokenIds = null);
	    IMemberSubBuilder<IQueryBuilder, NoSchema> AddGetNonceForChainAddressQuery(NonceInput input);
	    IMemberSubBuilder<IQueryBuilder, NamespacesConnection> AddNamespacesQuery(
	        string before = default,
	        string after = default,
	        float first = default,
	        float last = default);
	    IInterfaceSubBuilder<IQueryBuilder, INode> AddNodeQuery(string id);
	    IMemberSubBuilder<IQueryBuilder, OffChainAsset> AddOffChainAssetQuery(
	        string collectionId,
	        string tokenId = default);
	    IMemberSubBuilder<IQueryBuilder, OffChainAssetsConnection> AddOffChainAssetsQuery(
	        OffChainAssetsInput input,
	        string before = default,
	        string after = default,
	        float first = default,
	        float last = default);
	    IMemberSubBuilder<IQueryBuilder, AssetOwnersConnection> AddOwnersQuery(
	        string[] collectionIds,
	        string before = default,
	        string after = default,
	        float first = default,
	        float last = default);
	    IMemberSubBuilder<IQueryBuilder, SchemaCustomDomain> AddSchemaCustomDomainQuery(string domainName);
	    IMemberSubBuilder<IQueryBuilder, TokenSchema> AddTokenSchemaQuery(
	        string collectionId,
	        string tokenId = default);
	    IMemberSubBuilder<IQueryBuilder, TokenSchemasConnection> AddTokenSchemasQuery(
	        string collectionId,
	        string before = default,
	        string after = default,
	        float first = default,
	        float last = default);
	    IMemberSubBuilder<IQueryBuilder, Transaction> AddTransactionQuery(string transactionHash);
	    IMemberSubBuilder<IQueryBuilder, TransactionsConnection> AddTransactionsQuery(
	        string address,
	        string before = default,
	        string after = default,
	        float first = default,
	        float last = default);
	    IMemberSubBuilder<IQueryBuilder, WebhookEndpoint> AddWebhookEndpointQuery(string webhookId);
	    IMemberSubBuilder<IQueryBuilder, WebhookEndpointsConnection> AddWebhookEndpointsQuery(
	        string before = default,
	        string after = default,
	        float first = default,
	        float last = default);
	    IMemberSubBuilder<IQueryBuilder, WebhookSubscription> AddWebhookSubscriptionQuery(string subscriptionId);
	    IMemberSubBuilder<IQueryBuilder, WebhookSubscriptionsConnection> AddWebhookSubscriptionsQuery(
	        string webhookId,
	        string before = default,
	        string after = default,
	        float first = default,
	        float last = default);
	}

	
	/// <summary>
	/// Top level builder interface for generating mutations
	/// </summary>
	public interface IMutationBuilder : IRequestBuilder<IMutationBuilder>
	{
		IMemberSubBuilder<IMutationBuilder, Namespace> AddCreateNamespaceMutation(string domain, string suffix);
	}
}