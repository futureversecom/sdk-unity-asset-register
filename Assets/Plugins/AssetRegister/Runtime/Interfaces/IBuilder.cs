// Copyright (c) 2025, Futureverse Corporation Limited. All rights reserved.

using System;
using System.Linq.Expressions;
#if USING_UNITASK
using Cysharp.Threading.Tasks;
using System.Threading;
#else
using System.Collections;
#endif

namespace AssetRegister.Runtime.Interfaces
{
	/// <summary>
	/// Base class for all builders
	/// </summary>
	public interface IBuilder
	{
		/// <summary>
		/// Generates a request object based on the current state of the builder
		/// </summary>
		/// <returns>Request object</returns>
		IRequest Build();
#if USING_UNITASK
		/// <summary>
		/// Shortcut method that generates the Request, passes it to the client, and returns the response
		/// </summary>
		/// <param name="client">Asset Register client that processes the request</param>
		/// <param name="cancellationToken">Provides a way to cancel the current process</param>
		/// <returns>Response object generated by the client</returns>
		UniTask<IResponse> Execute(IClient client, CancellationToken cancellationToken = default);
#else
		/// <summary>
		/// Shortcut method that generates the Request, passes it to the client, and returns the response
		/// </summary>
		/// <param name="client">Asset Register client that processes the request</param>
		/// <param name="callback">Callback containing the response object></param>
		/// <returns>IEnumerator to yield on</returns>
		IEnumerator Execute(IClient client, Action<IResponse> callback);
#endif
	}

	/// <summary>
	/// Base class for sub-builders that are created by other builders
	/// </summary>
	/// <typeparam name="TBuilder">Parent builder that created this sub-builder</typeparam>
	public interface ISubBuilder<out TBuilder> : IBuilder where TBuilder : IBuilder
	{
		/// <summary>
		/// Use this when you have added all necessary fields for this builder to get back to the parent.
		/// </summary>
		/// <returns>The parent builder of this builder</returns>
		TBuilder Done();
	}

	/// <summary>
	/// Base class for top level builders that creates queries or mutations
	/// </summary>
	/// <typeparam name="TBuilder">The concrete type that implements this interface</typeparam>
	public interface IRequestBuilder<out TBuilder> : IBuilder where TBuilder : IRequestBuilder<TBuilder>
	{
		/// <summary>
		/// Add a header to the resulting GraphQL request (Content-Type is set by default)
		/// </summary>
		/// <param name="headerName"></param>
		/// <param name="value"></param>
		/// <returns>This builder</returns>
		TBuilder SetHeader(string headerName, string value);
		/// <summary>
		/// Shortcut for setting the Authorization header
		/// </summary>
		/// <param name="authToken">value of the Authorization header</param>
		/// <returns>This builder</returns>
		TBuilder SetAuth(string authToken);
	}

	/// <summary>
	/// Top level builder interface for generating queries
	/// </summary>
	public interface IQueryBuilder : IRequestBuilder<IQueryBuilder>
	{
		/// <summary>
		/// Add a sub-builder that is generated from a query object
		/// </summary>
		/// <param name="query">The query object that the builder is generated from</param>
		/// <typeparam name="TModel">The type of model that is queried</typeparam>
		/// <typeparam name="TInput">The type of input required by the query</typeparam>
		/// <returns>The generated sub-builder</returns>
		IMemberSubBuilder<IQueryBuilder, TModel> Add<TModel, TInput>(IQuery<TModel, TInput> query)
			where TModel : IModel where TInput : class, IInput;
	}
	
	/// <summary>
	/// Top level builder interface for generating mutations
	/// </summary>
	public interface IMutationBuilder : IRequestBuilder<IMutationBuilder>
	{
		/// <summary>
		/// Add a sub-builder that is generated from a mutation object
		/// </summary>
		/// <param name="mutation">The mutation object that the builder is generated from</param>
		/// <typeparam name="TModel">The type of model that is affected by the mutation</typeparam>
		/// <typeparam name="TInput">The type of input required by the mutation</typeparam>
		/// <returns>The generated sub-builder</returns>
		IMemberSubBuilder<IMutationBuilder, TModel> Add<TModel, TInput>(IMutation<TModel, TInput> mutation)
			where TModel : IModel where TInput : class, IInput;
	}

	/// <summary>
	/// Main sub-builder interface for building out requests
	/// </summary>
	/// <typeparam name="TBuilder">Parent builder that created this sub-builder</typeparam>
	/// <typeparam name="TType">Type of the member that this builder can add other members to</typeparam>
	public interface IMemberSubBuilder<out TBuilder, TType> : ISubBuilder<TBuilder>
		where TBuilder : IBuilder
	{
		/// <summary>
		/// Add a field from this member type to the query
		/// </summary>
		/// <param name="fieldSelector">Expression that returns a field from the member type.
		/// e.g. if TType is Asset, fieldSelector can be (Asset a) => a.TokenId, or simply a => a.TokenId
		/// </param>
		/// <typeparam name="TField">Type of the member that is selected by the fieldSelector expression</typeparam>
		/// <returns>This builder</returns>
		IMemberSubBuilder<TBuilder, TType> WithField<TField>(Expression<Func<TType, TField>> fieldSelector);
		/// <summary>
		/// Add a method from this member type to the query
		/// </summary>
		/// <param name="fieldSelector">Expression that returns a method call from the member type.
		/// e.g. if TType is SFTAssetOwnership, fieldSelector can be sft => sft.balanceOf("")
		/// </param>
		/// <typeparam name="TField">Return type of the method that is selected by the fieldSelector expression</typeparam>
		/// <returns>The generated sub-builder</returns>
		IMemberSubBuilder<IMemberSubBuilder<TBuilder, TType>, TField> WithMethod<TField>(Expression<Func<TType, TField>> fieldSelector);
		/// <summary>
		/// Adds a union from this member type to the query
		/// </summary>
		/// <param name="fieldSelector">Expression that returns a member of Union type from the member</param>
		/// <typeparam name="TField">The union type that is selected by the fieldSelector expression. Must derive IUnion</typeparam>
		/// <returns>The generated sub-builder</returns>
		IUnionSubBuilder<IMemberSubBuilder<TBuilder, TType>, TField> WithUnion<TField>(
			Expression<Func<TType, TField>> fieldSelector) where TField : class, IUnion;
	}

	/// <summary>
	/// Sub-builder for building out union types
	/// </summary>
	/// <typeparam name="TBuilder">Parent builder that created this sub-builder</typeparam>
	/// <typeparam name="TUnion">The union type that this builder is created for</typeparam>
	public interface IUnionSubBuilder<out TBuilder, in TUnion> : ISubBuilder<TBuilder>
		where TBuilder : IBuilder where TUnion : class, IUnion
	{
		/// <summary>
		/// Generates a sub-builder for a subtype of this Union
		/// </summary>
		/// <typeparam name="TUnionType">Must derive from TUnion</typeparam>
		/// <returns>Generated sub-builder</returns>
		public IMemberSubBuilder<IUnionSubBuilder<TBuilder, TUnion>, TUnionType> On<TUnionType>()
			where TUnionType : class, TUnion;
	}
}